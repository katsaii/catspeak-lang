# Catspeak cartridge layout #
# ========================= #

# The header comes first. In the order they are defined below, these values are
# written to the start of the buffer.

head-order: [signal, title, version]
head:
  signal:
    value-unfinished: 0x5B7859 #< The colour of Forest, if you know you know.
    value: 0xC7544E            #< The colour of Wanda,  if you know you know.
    type: u32
  title:
    value: "CATSPEAK CART"
    type: string
  version:
    value: 1
    type: u8

# Directly after the header are byte offsets, relative to the start of the
# Catspeak cartridge, each pointing to a specialised chunk of the Catspeak
# cartridge.
#
# In the order defined below, these are:

chunk-order: [instr, data, end]
chunk:
  instr: u32 #< The offset of the program section.
  data: u32  #< The offset of the data section.
  end: u32   #< The offset of the end of the Cartridge.

# The program section contains the executable code, encoded in reverse-polish
# notation. Each instruction is prefixed with an instruction opcode followed by
# any operands associated with the instruction.
#
# Although each instruction is of variable length, the complete program code
# is null-terminated.

instr-opcode: u8 #< The underlying type used for instruction opcodes.
instr:

# - name: "example"                     #< The name of the instruction.
#   name-short: "ex_1"                  #< A shorter name for the instruction.
#   desc: "just an example instruction" #< Instruction description.
#   repr: 0x0F                          #< Underlying opcode representation.
#   args:
#     - name: "n"                                   #< Operand name.
#       desc: "the number of hoops to jump through" #< Operand description.
#       type: u8                                    #< Operand type.
#   stackargs:
#     - name: "m" #< Pop value off the stack, and associate it with a name.
#       desc: "the number of additional hoops to jump through"
#   simple: true

  - name: "const number"
    name-short: "get_n"
    desc: "get a numeric constant"
    repr: 0x01
    args:
      - name: "value"
        desc: "the number to emit"
        type: f64
      - name: "dbg"
        desc: "the approximate location of the number in the source code"
        type: u32
        default: CATSPEAK_NOLOCATION
    simple: true
    comptime: value

  - name: "const bool"
    name-short: "get_b"
    desc: "get a boolean constant"
    repr: 0x02
    args:
      - name: "value"
        desc: "the bool to emit"
        type: u8
      - name: "dbg"
        desc: "the approximate location of the bool in the source code"
        type: u32
        default: CATSPEAK_NOLOCATION
    simple: true
    comptime: value

  - name: "const string"
    name-short: "get_s"
    desc: "get a string constant"
    repr: 0x03
    args:
      - name: "value"
        desc: "the string to emit"
        type: string
      - name: "dbg"
        desc: "the approximate location of the string in the source code"
        type: u32
        default: CATSPEAK_NOLOCATION
    simple: true
    comptime: value

  - name: "return"
    name-short: "ret"
    desc: "return a value from the current function"
    repr: 0x04
    args:
      - name: "dbg"
        desc: "the approximate location of the `return` keyword in the source code"
        type: u32
        default: CATSPEAK_NOLOCATION
    stackargs:
      - name: "result"
        desc: "the value to return"

  - name: "add"
    desc: "calculate the sum of two values"
    repr: 0x04
    args:
      - name: "dbg"
        desc: "the approximate location of the expression in the source code"
        type: u32
        default: CATSPEAK_NOLOCATION
    stackargs:
      - name: "lhs"
        desc: "the left-hand-side value of the sum"
      - name: "rhs"
        desc: "the right-hand-side value of the sum"
    simple: true
    comptime: lhs + rhs

# The data section stores a variety of information. Most importantly, it stores
# information about the main function (and function literals), such as how
# many local variables they contain.
#
# In the order defined below, these are:

data-order: [func, meta]
data:

  # The entry-point function must always be written to index [0].
  func-order: [locals]
  func-count: u32 #< The number of functions allocated, directly followed by...
  func:           #< `func-count`-many functions in the following layout:
    locals:
      name: "local variable"
      desc: "the max number of local variables this function can have"
      type: u32

  meta-order: [path, author]
  meta:
    path:
      desc: "the path to the file containing source code for this Cartridge"
      type: string
    author:
      desc: "the author of this Cartridge"
      type: string